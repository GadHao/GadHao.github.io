---
layout: page
title: 每日学习笔记
permalink: /notebook/
---

> 每日的学习笔记，主要用来发布前一天学习的所有理论知识，即每天早上8点30之后可以随时在这里看到之前的一天学习的内容有哪些，也可以看[提交记录](https://github.com/GadHao/gadhao.github.io/commits/master)追溯之前提交过的内容

## 总结[2020.09.17]

## 《深入了解计算机系统》的学习(Page30- Page34)

> 在准备这周六的知识分享内容，需要准备的较多，放缓了计算机系统的学习速度

大多数Intel兼容机都只用小端模式，另一方面，IBM和Oracle的大多数机器则是按照大端模式操作。许多比较新的微处理器使用的是双端法(bi-endian)，也就是说可以把它们配置成作为打断或者小段的机器运行。实际情况中，一旦选择了特定操作系统，字节顺序就固定了。选择何种字节顺序没有技术上的理由，只要选择了一种规则并且一直遵循，对于哪种字节排序的选择都是任意的。

对于大多数应用程序员来说，其机器所使用的字节顺序是完全不可见的。不过有时候，字节顺序会成为问题。在不同类型的机器之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反过来时，接受程序发现里面的字节成了反序的。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为它的内部表示

当阅读小端法机器生成的机器级程序表示时，经常会将字节按照相反的顺序显示。因为按照小端法，最低有效位在右边，所以会从右边开始排，这值得注意

还有一种情况是当编写规避正常的类型系统的程序时。在C语言中，可以通过强制类型转换(cast)或联合(union)来允许一种数据引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同。虽然很多应用编程都强烈不推荐这种编码技巧，但是它们对系统及编程来说是非常有用的

看这段代码：

```C
# include <stdio.h>
typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, size_t len){
    size_t i;
    for (i = 0; i < len; i++)
        printf(" %.2x", start[i]);
    printf("\n");
}

void show_int(int x){
    show_bytes((byte_pointer) &x, sizeof(int));
}

void show_float(float x){
    show_bytes((byte_pointer) &x, sizeof(float));
}

void show_pointer(void *x){
    show_bytes((byte_pointer) &x, sizeof(void *))
}
```

这段代码使用强制类型转换来访问和打印不同程序对象的字节表示。我们用`typedef`将数据类型`byte_pointer`定义为一个指向类型为`unsigned char`的对象的指针。这样一个字节指针引用一个字节序列，每个字节都被认为是一个非负整数。上面的代码中`show_bytes`函数传入了一个字节序列的地址(传入了字节指针和字节数)，字节数的数据类型是`size_t`，表示数据结构大小的首选数据类型。`show_bytes`打印出每个以十六进制表示的字节。C格式化指令`%.2x`表明整数必须用至少两个数字的十六进制格式输出

`show_bytes`之后的三个函数分别用`show_bytes`来输出了类型为`int`、`float`和`void *`的C程序对象的字节表示。在调用`show_bytes`时，传入的是被强制转换为`unsigned char *`类型的指向它们参数`x`的指针`&x`，这种强制类型转换告诉编译器，程序应该把这个指针看成指向一个字节序列，而不是指向一个原始数据类型的对象。然后，这个指针会被看成是对象使用的最低字节地址。注意这里使用了`sizeof`运算符来确定对象使用的字节数。一般来说，`sizeof(T)`返回存储一个类型为`T`的对象锁需要的字节数。使用`sizeof`而不是固定值，也有利于之后程序的移植。

![](/assets/img/CSAPP-24.JPG)

上图是在不同的机器/操作系统调用前面代码的输出结果，可以看到，除了数值类型因为小端法与大端法造成的字节输出顺序的不同之外，指针值也是完全不同的，不同的机器/操作系统使用不同的存储分配规则。另一个值得注意的特性是上面除了Linux 64使用8字节地址之外，其他操作系统都是使用4字节地址。

> C语言小技巧：`typeof`声明提供了一种给数据类型命名的方式。这能极大改善代码的可读性，因为深度嵌套的类型声明很难读懂；·`printf`(以及`fprintf`和`sprintf`)提供了一种打印信息的方式，在第一个参数格式串(format string)里，每个以`%`开始的字符序列都表示如何格式化下一个参数，比较典型的有`%d`是输出一个十进制整数，而`%c`是输出一个字符，其编码由参数给出，指定确定大小数据类型的格式，如`int32_t`，要更复杂一些，之后会提到
>
> 在函数`show_bytes`中，我们看到指针和数组之间紧密的关系，之后会详细介绍这一点。在代码中，我们还可以看到取地址运算符`&`，这分别创建了指向三种不同类型的`x`的指针，在这里三个指针的类型分别为`int*`、`float*`和`void **`(数据类型void *是一种特殊类型的指针，没有相关联的类型信息)
>
> 强制类型转换运算符可以将一种数据类型转换为另一种，比如`(byte_pointer)&x`表明无论指针`&x`以前是什么类型，它现在就是一个指向数据类型为`unsigned char`的指针。这里给出的强制类型转换不会改变真实的指针，它们只是告诉编译器以新的数据类型来看代被指向的数据。