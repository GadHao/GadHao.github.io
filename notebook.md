---
layout: page
title: 每日学习笔记
permalink: /notebook/
usemathjax: true
---

> 每日的学习笔记，主要用来发布前一天学习的所有理论知识，即每天早上8点30之后可以随时在这里看到之前的一天学习的内容有哪些，也可以看[提交记录](https://github.com/GadHao/gadhao.github.io/commits/master)追溯之前提交过的内容

## 总结[2020.09.27]

## 《深入了解计算机系统》的学习(Page46-Page50)

> 继续学习这一章，书里的信息量还是比较大的，这周又花太多时间在算法上了，学完CSAPP前面部分之后打算系统学习数据结构到算法的相关基础

#### 补码编码

对于许多应用，我们还希望表示负数值。最常见的有符号数的计算机表示方法就是*补码(two's-complement)*形式。在这个定义中，将字的最高有效位解释为*负权(negative weight)*。我们用函数$$B2T_w$$(Binary to Two's-complement的缩写，长度为$$w$$)来表示：

原理：补码编码的定义

对向量$$\vec{x}=[x_{w-1},x_{w-2},…,x_0]$$：

$$B2T_w(\vec{x})≐-x_{w-1}2^{w-1}+\sum^{w-2}_{i=0}x_i2^i$$

最高有效位$$x_{w-1}$$也称为符号位，它的"权重"为$-2^{w-1}$，是无符号表示中权重的负数。符号位被设置为1时，表示值为负，而当设置为0时，值为非负。这里来看几个示例：

$$B2T4([0001])=-0*2^3+0*2^2+0*2^1+1*2^0=0+0+0+1=1$$

$$B2T4([0101])=-0*2^3+1*2^2+0*2^1+1*2^0=0+4+0+1=5$$

$$B2T4([1011])=-1*2^3+0*2^2+1*2^1+1*2^0=-8+0+2+1=-5$$

$$B2T4([1111])=-1*2^3+1*2^2+1*2^1+1*2^0=-8+4+2+1=-1$$

![](/assets/img/CSAPP-43.JPG)

从图上可以看出，与一个位向量相关联的数值是由可能的向左指的条和向右直的条加起来决定的

可以看到，这张图的位模式和之前展示的无符号整数的位模式是一样的，但是当最高有效位是1时，数值是不同的，这是因为在第一种情况中，最高有效位的权重是+8，而在这里，它的权重是-8

所以我们可以想到$$w$$位补码所能表示的值的范围。它能表示的最小值是位向量$$[10…0]$$(也就是设置这个位为负权，但是清楚其他所有的位)，其整数值为$$TMin_w≐-2^{w-1}$$。而最大值是位向量$$[01…1]$$(清除具有负权的位，而设置其他所有的位)，其整数值为$$TMin_w≐-2^{w-1}$$，其整数值为$$TMax_w≐\sum^{w-2}_{i=0}2^i=2^{w-1}-1$$。以长度为4为例，我们有$$TMin_4=B2T_4([1000])=-2^3=-8$$，而$$TMax_4=B2T_4([0111])=2^2+2^1+2^0=4+2+1=7$$

我们可以看出$$B2T_w$$是一个从长度$$w$$的位模式到$$TMin_w$$和$$TMax_w$$之间的数字的映射，写作$$B2T_w:{0,1}^w→{TMin_w,…,TMax_w}$$。同无符号表示一样，在可表示的取值范围内的每个数字都有一个唯一的$$w$$位的编码编码。这就导出了与无符号数相似的补码数原理：

原理：补码编码的唯一性

函数$$B2T_w$$是一个双射

我们定义函数$$T2B_w$$(即"补码到二进制")作为$$B2T_w$$的反函数。也就是说，对于每个数$$x$$，满足$$TMin_w\leq{x}\leq{TMax_w}$$，即$$T2B_w(x)$$是$$x$$的(唯一的)$$w$$位模式

![](/assets/img/CSAPP-44.JPG)

观察上图可以发现：

- 补码的范围是不对称的：$$|TMin|=|TMax|+1$$，也就是说，$$TMin$$没有与之对应的正数，这导致了补码运算中某些特殊的属性，并且容易造成程序中细微的错误。之所以有这样的不对称性，是因为一半的位模式(符号位设置为1的数)表示负数，而另一半(符号位设置为0的数)表示非负数。因为0是非负数，也就意味着能表示的整数比负数少一个
- 最大的无符号数值正好比补码的最大值的两倍大一点：$$UMax_w=2TMax_w+1$$。补码表示中所有表示负数的位模式在无符号表示中都编程了正数
- $$-1$$和$$UMax$$有同样的位表示，即一个全1的串，数值0在两种表示方法中都是全0的串

C语言标准并没有要求要用补码形式来表示有符号整数，但是几乎所有的机器都是这么做的。程序员如果希望代码具有最大可移植性，能够在所有可能的机器上运行，那么除了上图中的那些范围，我们不应该假设任何可表示的数值范围，也不应该假设有符号数回使用何种特殊的表示方式。另一方面，许多程序的书写都假设用补码来表示有符号数，并且具有上面描述的那些"典型的"取值范围，这些程序也能够在大量的机器和编译器上移植。

C库中的文件`<limits.h>`定义了一组常量来限定编译器运行的这台机器的不同整型数据类型的取值范围。比如，其定义了常量`INT_MAX`、`INT_MIN`和`UNIT_MAX`，它们描述了有符号和无符号整数的范围。对于一个补码的机器，数据类型`int`有$$w$$位，这些常量就对应于$$TMax_w$$、$$TMin_w$$和$$UMax_w$$的值



#### 有符号数和无符号数之间的转换

C语言允许在各种不同的数字数据类型之间做强制类型转换。例如，假设变量`x`声明为`int`，`u`声明为`unsigned`。表达式`(unsigned)x`会将`x`的值转换成一个无符号数值，而`(int)u`将`u`的值转换成一个有符号整数。将有符号整数强制类型转换成无符号数，或者反过来，会得到什么结果呢。很明显，我们是希望这些值保持不变的，可以想象将负数转换成无符号数可能回得到0，如果转换的无符号数太大以至于超出了补码能够表示的范围，可能会得到$$TMax$$。不过，对于大多数C语言的实现来说，对这个问题的回答都是从位级角度来看的，而不是数的角度

比如说，考虑下面的代码：

```c
short int v = -12345;
unsigned short uv = (unsigned short)v;
printf("v = %d, uv = %u\n", v, uv);
```

在一台使用补码的机器上，上述代码会产生如下输入：

```
v = -12345, uv = 53191
```

我们看到，强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。`-12345`的16位补码表示与`53191`的16位无符号表示是完全一样的。将`short`强制类型转换为`unsigned short`改变数值，但是不改变位表示。

类似地，考虑这段代码：

```c
unsigned u = 4294967295u; /* UMax */
int tu = (int)u;
printf("u = %u, tu = %d\n", u, tu);
```

在一台采用补码的机器上，会产生如下输出：

```
u = 4294967295, tu = -1
```

因为对于32位字长来说，无符号形式的`4294967295`($$UMax_{32}$$)和补码形式的`-1`的位模式是完全一样的。将`unsigned`强制类型转换成`int`，底层的位表示保持不变。

对于打输出C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。

可以用更数学化的方法表示：$$T2U_w(x)≐B2U_w(T2B_w(x))$$和$$U2T_w(x)≐B2T_w(U2B_w(x))$$都是成立的

<br><br><br><br><br><br>