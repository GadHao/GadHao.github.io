---
layout: page
title: 每日学习笔记
permalink: /notebook/
usemathjax: true
---

> 每日的学习笔记，主要用来发布前一天学习的所有理论知识，即每天早上8点30之后可以随时在这里看到之前的一天学习的内容有哪些，也可以看[提交记录](https://github.com/GadHao/gadhao.github.io/commits/master)追溯之前提交过的内容

## 总结[2020.10.10]

> 最近的日常依然是做算法，还有继续读这本CSAPP，不得不说实在是看得太慢了，特别是最近在看浪潮之巅，继续吧，计划是要把这本书的前三章看完才开始其他基础知识的学习的，还是要继续呀

## 《深入了解计算机系统》的学习(Page57-Page60)

**原理：截断无符号数**

令$$\vec{x}$$等于位向量$$[x_{w-1,x_{w-2},…,x_0}]$$，而$$\vec{x′}$$是将其截断为`k`位的结果：$$\vec{x′}=[x_{k-1},x_{k-2},…,x_0]$$。令$$x=B2U_w(\vec{x})$$，$$x′=B2U_k(\vec{x′})$$，则$$x′=xmod 2^k$$

该原理背后的直觉是所有被截取的位其权重形式都是$$2^i$$，其中$i\geq{k}$，因此，每一个权在取模操作下结果都为零

推导：截断无符号数

$$
B2U_w([x_{w-1},x_{x-2},…,x_0]) mod 2^k=[\sum^{w-1}_{i=0}x_i2^i]mod2^k\\
=[\sum^{k-1}_{i=0}x_i2^i]mod2^k\\
=\sum^{k-1}_{i=0}x_i2^i\\
=B2U_k([x_{k-1},x_{k-2},…,x_0])
$$

这段推导主要利用了属性：对于任何$$i\geq{k}$$，$$2^imod2^k=0$$

补码截断也具有相似的属性，只不过要将最高位转换为符号位：

原理：截断补码数值

因为之前得到了无符号数截断的公式，所以现在将其转换为补码即可，则补码数字的截断结果是：

$$B2T_k[x_{k-1},x_{k-2},…,x_o]=U2T_k(B2U_w([x_{w-1},x_{w-2},…,x_o])mod2^k)$$



#### 关于有符号数与无符号数的建议

可以看到，有符号数到无符号数的强制类型转换导致了某些非直观的行为。这些非直观的特性经常导致程序错误，并且这种包含隐式强制类型转换的细微差别的错误很难被发现。因为这种强制转换是在代码中没有明确指示的时候发生的，程序员经常忽视了它的影响

这边来看两道题：

![](/assets/img/CSAPP-47.JPG)

首先我们在之前了解到*执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。*

所以这里当`length`为0时，把`length-1`看成无符号的0加上有符号的-1，又因为我们知道补码转换成有符号数的转换公式是$$T2U_w(x)=x+x_{w-1}2^w$$，所以这里的结果相当于$$-1+1×2^{32}=4,294,967,295$$，所以会遇到错误，这里有很多种改法，只要避免了这种情况就行了，比如在这里先判断`length`的值，如果等于0，直接`return result`

![](/assets/img/CSAPP-48.JPG)

A. 在`strlen(t)`大于`strlen(s)`时会出现步正确的结果

B. 因为两个无符号数相减，最后的结果也是无符号数，而此时本来应该输出一个负数，所以这里会用得到相应补码数对应的无符号数，答案会不直观

C. 改成直接比较，把`return strlen(s) - strlen(t) > 0;`改成`return strlen(s) > strlen(t)`

<br><br><br><br><br><br>