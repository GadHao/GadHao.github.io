---
layout: page
title: 每日学习笔记
permalink: /notebook/
---

> 每日的学习笔记，主要用来发布前一天学习的所有理论知识，即每天早上8点30之后可以随时在这里看到之前的一天学习的内容有哪些，也可以看[提交记录](https://github.com/GadHao/gadhao.github.io/commits/master)追溯之前提交过的内容

## 总结[2020.09.13]

## 《深入了解计算机系统》的学习(Page12- Page17)

进程是操作系统对一个正在运行的程序的一种抽象。并发运行，指的是一个进程的指令和另一个进程的指令是交错的。无论是单核还是多核系统，一个CPU看上去都像是在并发地执行多个进程，这通过处理器在进程间切换来实现。操作系统中实现这种交错执行的机制被称为*上下文切换*。

操作系统保持跟踪进程运行需要的所有状态信息，这种状态，也就是上下文，里面包含了许多信息，比如PC和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程，新进程从上次停止的地方继续。

![](../../assets/img/CSAPP-9.JPG)

从一个进程到另一个进程的转换是由操作系统内核(kernel)管理的。控制权在进程A -> 内核 -> 进程B ……来回传递。内核不是一个独立的进程，它是系统管理全部进程所用代码和数据结构的集合。



#### 线程

一个进程可以由多个称为线程的执行单元组成，线程在进程的上下文中共享同样的代码和全局数据，因为多线程之间比多进程之间更容易共享数据，而且一般比进程更高效。所以有多处理器可用的时候，多线程也是一种使得程序可以运行得更快的方法。



#### 虚拟内存

虚拟内存是一个抽象概念，每个进程看到的内存都是一致的，称为虚拟空间地址，地址最上面的区域是保留给操作系统中的代码和数据的，对所有进程来说都是一样的。地址空间的底部区域存放用户自定义的进程的代码和数据。地址是从下往上增大的。

![](../../assets/img/CSAPP-10.JPG)

从最低的内存地址开始，简单了解一下虚拟内存的各个区：

- **程序代码和数据**：对所有进程来说，代码是从同一个固定地址开始，紧接着是和C全局变量相对应的数据位置，这个区域是直接按照可执行目标文件的内容初始化的
- **堆**：代码和数据区后面紧跟着运行时堆。和代码和数据区不一样，这个区不是固定大小的，而是可以动态地扩展和收缩
- **共享库**：地址空间的空间部分有一块用来存放C标准库，数学库等共享库的代码和数据的区域
- **栈**：位于用户虚拟地址空间顶部，编译器用它实现函数调用。其也可以动态地扩展和收缩。当我们调用一个函数时，其会增长；从一个函数返回时，栈就会收缩
- **内核虚拟地址**：地址空间顶部的区域，是为内核保留的，不允许应用程序独写这个区域的内容或者直接调用内核代码定义的函数，它们必须通过内核来执行这些操作

虚拟内存的运作需要硬件和操作系统之间精密复杂的交互。



#### 文件

文件就是字节序列，仅此而已。每个I/O设备，磁盘、键盘、显示器，甚至网络，都可以看成是文件。系统中所有输入输出都通过一小组称为Unix I/O的系统函数调用读写文件来实现

文件这个简单而精致的概念非常强大。它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的I/O设备



### 系统之间通过网络通信

现代系统经常通过网络和其他系统连接到一起。从一个单独的系统看，网络可视为一个I/O设备。当系统从主存复制一串字节到网络适配器，数据流经过网络到达另一台机器，而不是到达本地磁盘驱动器。同样，也可以读取从其他机器发送来的数据，并把数据复制到自己的主存

![](../../assets/img/CSAPP-11.JPG)

### 重要主题

通过前面所有的漫游内容，我们可以得出一个很重要的观点，那就是系统不仅仅只是硬件。而是硬件和系统软件互相交织的集合体，它们必须共同协作以达到运行应用程序最终的目的。

通过之后对这些知识的深入学习，可以帮助我们写出更快速、更可靠、更安全的程序。

#### Amdahl定律

*Gene Amdahl*，对提升系统某一部分性能所带来的效果做出了观察，这个观察被称为*Amdahl定律(Amdahl's law)*。该定律主要思想是：

当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。

> 假如原本执行某应用程序需要的时间为Told。假设系统某部分所需执行时间与该时间的比例为a，该部分的性能提升比例为k。则该部分初始所需时间为aTold，现在所需时间为(a*Told)/k，因此，总的执行时间应为

![](../../assets/img/CSAPP-12.JPG)

上面是书里对*Amdahl定律*的解释，看完之后是不是觉得还有一点不明白是什么意思，特别是这里是两个比例

这里再详细了解一下这个定律，首先这个定律在中文中通常被音译成*阿姆达尔定律*，阿姆达尔曾致力于并行处理系统的研究。把a看作并行计算部分所占比例，k为并行处理节点个数，假设a占100%，即1-a=0，整个程序都是并行执行时，k带来的收益是最高的。当a占0%，即整个程序都是串行执行时，无论如何增加k，都不会提高加速比。

还有一种情况，考虑k趋向于∞时的效果，可以看出，此时a/k几乎可以忽略不计，于是我们得到：

![](../../assets/img/CSAPP-13.JPG)

如果百分之60%的计算可以加速到几乎不花时间的程度，我们获得的加速比仍然只有1/0.4=2.5X[^6]

阿姆达尔定律描述了改善任何过程的一般原则，其主要观点是：想要显著加速整个系统，必须提升全系统中相当大的部分的速度。这个定律除了可以用在加速计算机系统方面，还可以用在公司降低制造成本，或者学生提高绩点平均值等方面。

可以看出，如果我们想提高一个程序的运行效率提高2倍或更高的比例，只有通过很大一部分系统的组件才能得到

书中有两道练习题：

![](../../assets/img/CSAPP-14.JPG)

![](../../assets/img/CSAPP-15.JPG)

贴上答题过程：

![](../../assets/img/CSAPP-16.JPG)

![](../../assets/img/CSAPP-17.JPG)

<br/><br/><br/><br/><br/><br/>


[^6]: 书里用X来表示加速比的单位，没有找到比较详细的介绍，这里也直接用X来表示