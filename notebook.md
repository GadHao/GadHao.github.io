---
layout: page
title: 每日学习笔记
permalink: /notebook/
usemathjax: true
---

> 每日的学习笔记，主要用来发布前一天学习的所有理论知识，即每天早上8点30之后可以随时在这里看到之前的一天学习的内容有哪些，也可以看[提交记录](https://github.com/GadHao/gadhao.github.io/commits/master)追溯之前提交过的内容

## 总结[2020.10.2]

## 《深入了解计算机系统》的学习(Page50-Page57)

通过前面的所有例子，我们还可以看到，位模式相同的补码与无符号数之间的关系可以表示为函数$$T2U$$的一个属性：

**原理：补码转换为无符号数**

对满足$$TMin_w\leq{x}\leq{TMax_w}$$的$$x$$有：


$$
T2U_w(x)=\begin{cases}
x+2^w,x<0\\
x,x\geq0
\end{cases}
$$


比如，我们看到$$T2U_{16}(-12345)=-12345+2^{16}=53191$$，$$T2U_w(-1)=-1+2^w=UMax_w$$

推导过程：补码转换为无符号数

因为对于位模式$$\vec{x}$$，如果我们计算$$B2U_w(\vec{x})-B2T_w\vec{(x)}$$的差，从`0`到`w-2`的位的加权和互相抵消掉，剩下一个值：

$$B2U_w(\vec{x})-B2T_w(\vec{x})=x_{w-1}(2^{w-1}-(-2^{w-1}))=x_{w-1}2^w$$

这就得到一个关系：$$B2U_w(\vec{x})=x_{w-1}2^w+B2T_w(\vec{x})$$，因此就有：

$$B2U_w(T2B_w(x))=T2U_w(x)=x+x_{w-1}2^w$$

如何理解上面两个式子的关系呢，首先$$T2B_w(x)$$把当前补码数转换成二进制表示，再通过$$B2U_w(\vec{x})$$转换成无符号整数，所以这里的$$B2U_w(T2B_w(x))$$和$$B2U_w(\vec{x})$$是等效的，即从补码数到无符号数的转换操作$$T2U_w(x)$$。再根据上面的关系$$B2U_w(\vec{x})=x_{w-1}2^w+B2T_w(\vec{x})$$，现在$$B2T_w(\vec{x})$$的值就是$$x$$，所以推导出了最后的公式

![](/assets/img/CSAPP-45.JPG)

这张图说明了函数$$T2U$$的一般行为，当将一个有符号数映射为相应的无符号数时，负数会被转换成大的正数，非负数会保持不变



接着，我们来考虑将一个无符号数转换为补码

**原理：无符号数转换为补码**

对满足$$0\leq{u}\leq{UMax_w}$$的$$u$$有：
$$
U2T_w(u)=\begin{cases}
u,u\leq{TMax_w}\\
u-2^w,u>TMax_w
\end{cases}
$$
该原理证明如下：

推导：无符号数转换为补码

设$$\vec{u}=U2B_w(u)$$，并且这个位向量也是$$U2T_w{u}$$的补码表示，根据无符号数编码和补码编码的定义，即

$$B2U_w(\vec{x})≐\sum^{w-1}_{i=0}x_i2^i$$和$$B2T_w(\vec{x})≐-x_{w-1}2^{w-1}+\sum^{w-2}_{i=0}x_i2^i$$

我们将其结合起来，所以得到了$$U2T_w(u)=-u_{w-1}2^w+u$$

可以看到，位$$u_{w-1}$$决定了$$u$$是否大于$$TMax_w=2^{w-1}-1$$

 

**总结**：当$$0\leq{x}\leq{TMax_w}$$之内的值$$x$$而言，我们得到$$T2U_w{x}=x$$和$$U2T_w{x}=x$$，即在这个范围内的数字的无符号和补码表示的值是相同的。在这个范围以外的数值，转换需要加上或者减去$$2^w$$



#### C语言中的有符号数与无符号数

尽管C语言标准没有指定有符号数要采用某种表示，但是几乎所有的机器都使用补码。通常，大多数数字都默认为是有符号的。例如，声明一个像`12345`或者`0x1A2B`这样的常量时，这个值就被认为是有符号的。加上后缀字符`U`或者`u`，例如`12345U`或`0x1A2Bu`

C语言允许无符号数有符号数的转换，虽然C标准没有精确规定要如何进行这种转换，但大多数系统遵循的原则是底层的位表示不变。即之前提到过的那些函数的规则($$U2T_w$$，$$T2U_w$$等)

显式的强制类型转换会导致转换发生，比如：

```c
int tx, ty;
unsigned ux, uy;

tx = (int) ux;
uy = (unsigned) ty;
```

另外，当一种类型的表达式被赋值给另一种类型的变量时，转换是隐式的，比如：

```c
int tx, ty;
unsigned ux, uy;

tx = ux; /* Cast to signed */
uy = ty; /* Cast to unsigned */
```

当用`printf`输出数值时，用指示符`%d`、`%u`和`%x`以有符号十进制、无符号十进制和十六进制格式输出一个数字。注意其可以用指示符`%u`来输出类型为`int`的数值，也可以用指示符`%d`输出类型为`unsigned`的数值，比如：

```c
int x = -1;
unsigned u = 2147483648; /* 2 to the 31st */

printf("x = %u = %d\n", x, x);
printf("u = %u = %d\n", u, u);
```

在一个32位机器上运行时，其输出：

`x = 4294967295 = -1`

`u = 2147483648 = -2147483648`

提示：结合前面的函数$$T2U_w(x)=x+x_{w-1}2^w$$，所以$$T2U_{32}(-1)=-1+2^{32}=UMax_{32}$$

$$U2T_w(u)=-u_{w-1}2^w+u$$，所以$$U2T_{32}(2^{31})=-2^{32}+2^{31}=-2^{31}=TMin_{32}$$



由于C语言同时包含有符号和无符号数表达式的处理方式，所以会出现一些奇特的行为。当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。这里的运算主要是说的对于像<和>这样的关系运算符，对于标准的算数运算来说则没有什么影响，可以看这张图，由于发生了隐式转换，所以会产生没那么直观的结果：

![](/assets/img/CSAPP-46.JPG)

注意：这里为什么没有直接用$$-2147483648$$或者$$0x80000000$$来表示$$TMin_{32}$$呢，这是由于补码的不对称性和C语言的转换规则之间奇怪的交互。虽然理解这个问题需要我们去关注C语言标准的一些比较隐晦的角落，但是它能帮助我们充分领会整数数据类型及其表示的一些细微之处

#### 扩展一个数字的位表示

一个常见的操作是要在不同字长的整数之间做转换，同时又保持数值不变。当目标数据类型太小，以至于根本表示不了想要的值时，这根本就是不可能的，而从一个较小的数据类型转换到一个较大的类型时，应该总是可能的。

要将一个无符号数转换成一个更大的数据类型，只需要简单地在表示的开头添加0，这种运算被称为*零扩展(zero extension)*

**原理：无符号数的零扩展**

定义宽度为$$w$$的位向量$$\vec{u}=[u_{w-1},u_{w-2},…,u_0]$$以及宽度为$$w^′$$的位向量$$\vec{u′}=[0,…,0,u_{w-1},u_{w-2},…,u_0]$$，其中$$w′>w$$。则$$B2U_w(\vec{u})=B2U_{w′}(\vec{u′})$$

这个原理相当于是直接遵循了无符号数编码定义的结果

要将一个补码数字转换成一个更大的数据类型，可以执行一个*符号扩展(sign extension)*，在表示中添加最高有效位的值，表示为如下原理：

**原理：补码数的符号扩展**

定义宽度为$$w$$的位向量$$\vec{x}=[x_{w-1},x_{w-2},…,x_0]$$和宽度为$$w$$的位向量$$\vec{x′}=[x_{w-1},…,x_{w-1},x_{w-1},x_{w-2},…,x_0]$$，其中$$w′>w$$。则$$B2T_w(\vec{x})=B2T_{w′}(\vec{x′})$$



例如这段代码：

```c
short sx = -12345; /* -12345 */
unsigned short usx = sx; /* 53191 */
int x = sx; /* -12345 */
unsigned ux = usx; /* 53191 */

printf("sx = %d:\t", sx);
show_bytes((byte_pointer) &sx, sizeof(short));
printf("usx = %u:\t", usx);
show_bytes((byte_pointer) &usx, sizeof(unsigned short));
printf("x = %d:\t", x);
show_bytes((byte_pointer) &x, sizeof(int));
printf("ux = %u:\t", ux);
show_bytes((byte_pointer) &ux, sizeof(unsigned));
```

在采用补码表示的32位大端法机器上运行这段代码，输出：

```
sx = -12345: cf c7
usx = 53191: cf c7
x = -12345: ff ff cf c7
ux = 53191: 00 00 cf c7
```

可以看到，尽管$$-12345$$的补码表示和$$53191$$的无符号表示在16位字长是相同的，但是在32位字长时却是不同的。比如这里$$-12345$$的十六进制表示为$$0xFFFFCFC7$$，而$$53191$$的十进制表示为$$0x0000CFC7$$。前者使用的是符号扩展，即最开头加了16位，都是最高有效位1，表示为十六进制就是$$0xFFFF$$。后者开头使用16个0来扩展，表示为十六进制就是$$0x0000$$

比如一个位向量$$[101]$$表示值$$-4+1=-3$$。对其应用符号扩展，得到位向量$$[1101]$$，表示的值$$-8+4+1=-3$$。我们可以看到，对于$$w=4$$，最高两位的组合值是$$-8+4=-4$$，与$$w=3$$时符号位的值相同。类似地，位向量$$[111]$$和$$[1111]$$都表示值$$-1$$

有了这个直觉，我们现在可以展示保持补码值的符号扩展

推导：补码数值的符号扩展

令$$w′=w+k$$，我们想要证明的是

$$B2T_{w+k}([x_{w-1},x_{w-1},x_{w-2},…,x_0])=B2T_w([x_{w-1},x_{w-2},…,x_0])$$

如果我们能证明符号扩展一位保持了数值不变，那么符号扩展任意位都能保持这种属性。因此，证明的任务就变为了：

$$B2T_{w+1}([x_{w-1},x_{w-1},x_{w-2},…,x_0])=B2T_w([x_{w-1},x_{w-2},…,x_0])$$

根据补码编码的定义展开左边的表达式，得到：

$$
B2T_{w+1}([x_{w-1},x_{w-1},x_{w-2},…,x_0])=-x_{w-1}2^w+\sum^{w-1}_{i=0}x_i2^i\\
=-x_{w-1}2^w+x_{w-1}2^{w-1}+\sum^{w-2}_{i=0}x_i2^i\\
=-x_{w-1}(2^w-2^{w-1})+\sum^{w-2}_{i=0}x_i2^i\\
=-x_{w-1}2^{w-1}+\sum^{w-2}_{i=0}x_i2^i\\
=B2T_w([x_{w-1,x_{w-2},…,x_0}])
$$

从上面的推算过程可以看出，有没有新加的位，得到的结果都是相同的，运算的结果会得到相同的数值



#### 截断数字

假设我们不用额外的位来扩展一个数值，而是减少表示一个数字的位数。例如下面代码中这种情况：

```c
int x = 53191;
short sx = (short) x; /* -12345 */
int y = sx;
```

当我们把`x`强制类型转换为`short`时，我们就将32位的`int`截断为了16位的`short int`。就像前面看到的，这个16位的位模式就是`-12346`的补码表示。当我们把其强制转换为`int`时，符号扩展把高16位设置为1，从而生成-12345的32位补码表示

当将一个$$w$$位的数$$\vec{x}=[x_{w-1},x_{w-2},…,x_0]$$截断为一个k位数字时，我们会丢弃掉高`w-k`位，得到一个位向量$$\vec{x′}=[x_{k-1}，x_{k-2},…,x_0]$$。截断一个数字可能会改变它的值，这是溢出的一种形式，对于一个无符号数，我们可以很容易得出其数值结果

<br><br><br><br><br><br>