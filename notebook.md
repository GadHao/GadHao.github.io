---
layout: page
title: 每日学习笔记
permalink: /notebook/
---

> 每日的学习笔记，主要用来发布前一天学习的所有理论知识，即每天早上8点30之后可以随时在这里看到之前的一天学习的内容有哪些，也可以看[提交记录](https://github.com/GadHao/gadhao.github.io/commits/master)追溯之前提交过的内容

## 总结[2020.09.22]

## 《深入了解计算机系统》的学习(Page38-Page42)

> 晚上学习理论知识的效率和早上相比差太多了，之后晚上只写代码，把这部分知识的学习和巩固放到早上上班之前进行。另外还需要抽空添加博客对*LaTeX*语法的支持

![](/assets/img/CSAPP-31.JPG)

![](/assets/img/CSAPP-32.JPG)

答案：

`bis(x,y)` `bis(bic(x,y),bic(y,x))`

`bis`和`OR`等价，如果`x`或`y`对应的位为1，则最后的结果相应的位会是`1`，所以得到第一个答案，另外，`bic(x,m)`等价于`x&~m`，只有当`x`对应的位为1且`m`对应的位为0的时候，最后的结果的对应位才等于1，因为`x^y`等价于`(x&~y)|(~x&y)`，所以得到第二个答案

关于这个答案，首先一定要仔细审题，理解`bis`和`bic`指令的作用，然后要理解这些操作的等价关系，特别是对于这里的`bic`操作，在`m`为1的每个位置，将`z`对应的位设置为0，也就是说和上面解释的一样，`m`对应的位为0且`x`对应的位不为0，最后的结果的对应位才为1

#### C语言中的逻辑运算

C语言还提供了一组逻辑运算符`||`、`&&`和`!`，分别对应命题逻辑中的`OR`、`AND`和`NOT`运算。逻辑运算很容易和位级运算相混淆，但是它们的功能是完全不同的。逻辑运算认为所有非零的参数都表示TRUE，而参数0表示FALSE。它们返回1或者0，分别表示结果为TRUE或者为FALSE。这里是一些示例：

![](/assets/img/CSAPP-33.JPG)

可以观察到，按位运算只有在特殊条件下，即参数被限制为0或者1时，才与其对应的逻辑运算有相同的行为。

逻辑运算符`&&`和`||`与 它们对应的位级运算`&`和`|`之间第二个重要的区别是，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。

![](/assets/img/CSAPP-34.JPG)

这里直接做第二题：`!(x^y)`



#### C语言中的移位运算

C语言还提供了一组移位运算，向左或者向右移动位模式。对于一个位表示为$[x_{w-1},x_{w-2},…,x_0]$的操作数$x$，C表达式`x<<k`会生成一个值，其位表示为$[x_{w-k-1},x_{w-k-2},…,x_0,0,…,0]$。也就是说，`x`向左移动`k`位，丢弃最高的`k`位，并在右端补`k`个0。移位量应该是一个0~w-1之间的值。移位运算是从左至右可结合的，所以`x<<j<<k`等价于`(x<<j)<<k`

有一个相应的右移运算`x>>k`，但是它的行为有点微妙。一般来说，机器支持两种形式的右移：逻辑右移和算数右移。逻辑右移在左端补`k`个0，得到的结果是$[0,…,0,x_{w-1},x_{w-2},…,x_k]$。算数右移是在左端补`k`个最高有效位的值，得到的结果是$[x_{w-1},…,x_{w-1},x_{w-1},x_{w-2},…,x_k]$。这种做法看上去可能有点奇特，但是我们会发现它对有符号整数数据的运算非常有用

让我们看一个例子，这个例子对一个8位参数`x`的两个不同的值做了不同的移位操作：

![](/assets/img/CSAPP-35.JPG)

图中斜体数字表示的是因为移位运算而填充的值，可以看到除了算数右移`[10010101]`时，其他情况填充的值都是0，因为其最高位是1，所以算数右移之后填充的也是1

C语言标准没有明确定义有符号数应该使用哪种类型的右移，即算数右移或逻辑右移都可以，所以也意味着可能会出现可以执行问题。在实际情况中，几乎所有的编译器/机器都对有符号数使用算数右移，且虚度哦程序员也都假设机器会使用这种右移。而对于无符号数来说，右移必须是逻辑的。而Java中对右移的具体方式有明确的定义，比如`x>>k`会将`x`算数右移`k`个位置，而`x>>>k`会对`x`做逻辑右移