---
layout: post
title: 'Rust学习笔记(2) - 认识所有权'
date: 2020-08-04
author: HANABI
color: rgb(59,46,42)
tags: Rust
---

> 所有权机制是Rust最与众不同的特性，它让Rust无需垃圾回收(garbage collector)就能保障内存安全

## 什么是所有权(ownership)？

所有运行的程序都必须管理其使用计算机内存的方式，有一些语言具有GC机制，在程序运行时不断寻找不再使用的内存；还有一些语言，需要程序员亲自分配和释放内存。而在Rust中，是通过所有权机制来管理内存的，编译器在编译时会根据一系列规则进行检查，在运行时，所有权系统内部的所有功能都不会减慢程序

在了解所有权之前，我们要先了解栈(Stack)与堆(Heap)的概念

> ### 栈（Stack）与堆（Heap）
>
> 在很多语言中，你并不需要经常考虑到栈与堆。不过在像 Rust 这样的系统编程语言中，值是位于栈上还是堆上在更大程度上影响了语言的行为以及为何必须做出这样的抉择。我们会在本章的稍后部分描述所有权与栈和堆相关的内容，所以这里只是一个用来预热的简要解释。
>
> 栈和堆都是代码在运行时可供使用的内存，但是它们的结构不同。栈以放入值的顺序存储值并以相反顺序取出值。这也被称作 **后进先出**（*last in, first out*）。想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，也从顶部拿走。不能从中间也不能从底部增加或拿走盘子！增加数据叫做 **进栈**（*pushing onto the stack*），而移出数据叫做 **出栈**（*popping off the stack*）。
>
> 栈中的所有数据都必须占用已知且固定的大小。在编译时大小未知或大小可能变化的数据，要改为存储在堆上。堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 **指针**（*pointer*）。这个过程称作 **在堆上分配内存**（*allocating on the heap*），有时简称为 “分配”（allocating）。将数据推入栈中并不被认为是分配。因为指针的大小是已知并且固定的，你可以将指针存储在栈上，不过当需要实际数据时，必须访问指针。
>
> 想象一下去餐馆就座吃饭。当进入时，你说明有几个人，餐馆员工会找到一个够大的空桌子并领你们过去。如果有人来迟了，他们也可以通过询问来找到你们坐在哪。
>
> 入栈比在堆上分配内存要快，因为（入栈时）操作系统无需为存储新数据去搜索内存空间；其位置总是在栈顶。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，并接着做一些记录为下一次分配做准备。
>
> 访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。现代处理器在内存中跳转越少就越快（缓存）。继续类比，假设有一个服务员在餐厅里处理多个桌子的点菜。在一个桌子报完所有菜后再移动到下一个桌子是最有效率的。从桌子 A 听一个菜，接着桌子 B 听一个菜，然后再桌子 A，然后再桌子 B 这样的流程会更加缓慢。出于同样原因，处理器在处理的数据彼此较近的时候（比如在栈上）比较远的时候（比如可能在堆上）能更好的工作。在堆上分配大量的空间也可能消耗时间。
>
> 当你的代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束时，这些值被移出栈。
>
> 跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。一旦理解了所有权，你就不需要经常考虑栈和堆了，不过明白了所有权的存在就是为了管理堆数据，能够帮助解释为什么所有权要以这种方式工作。

记住Rust所有权的规则：

1. Rust 中的每一个值都有一个被称为其 **所有者**（*owner*）的变量。
2. 值在任一时刻有且只有一个所有者。
3. 当所有者（变量）离开作用域，这个值将被丢弃。

## 通过String类型来认识所有权

首先，我们来看简单情况，我们都知道，所有编程语言都有变量*作用域(scope)*的概念，Rust也不例外，我们来看一段代码：

```rust
fn main() {
    {
        let mut num = 2;
    }

    // not found in this scope
    num = 4;

    println!("{}", num);
}
```

可以看到，注释部分表示了上面代码在编译的时候会注明的error，提示在当前作用域中不存在`num`这个变量，到这里为止，Rust的作用域相关特征都还和其他编程语言类似，`num`是一个基本类型的变量，其储存在栈上，当离开作用域时被移出栈

在介绍更复杂的所有权规则之前，我们先来介绍一种比之前都要复杂的数据类型，`String`类型，它和之前我们用`let s = "hello, world!"`定义的字符串字面值不一样，字符串字面值是不可变的，而`String`类型是可变的

来看两段代码：

```rust
fn main() {
    let mut s = "hello";
    // cannot add `&str` to `&str`
    s = s + ", world! ";
}
```

```rust
fn main() {
    let mut s = String::from("hello");
    s = s + ", world!";
    println!("{}", s);
}
```

在第一段代码中，我们定义了一个字符串字面量，当我们试图在其后面添加新的内容时，出现了编译错误，而在第二段代码中，我们定义了一个`String`类型的变量，就可以在后面添加新的内容了，那么，第二段代码是什么意思呢

对于字符串字面量，我们在编译时就知道其内容，它被直接硬编码进最后的可执行文件中。而我们在第二段代码中用了`String::from("hello")`来定义了一个字符串变量(`String::from`这样的写法会在以后学习到)，可以存储在编译时未知大小的字符串内容，它可能会随着程序的运行而改变，所以不能硬编码进二进制文件，需要在对上分配一块在编译时未知大小的内容来存放

这个变量被分配到堆上，意味着：

- 必须在运行时向操作系统请求内存
- 当处理完这个变量时，我们要将内存返回给操作系统

第一点当我们在调用`String::from`时就已经完成了，在许多编程语言中，都是这么做的，对于第二点，每种编程语言就有区别了，在有`GC`的语言中，`GC`记录并清除不再使用的内存，在没有`GC`的语言中，手动释放不再使用的内存就是我们的责任。正确处理内存回收是一个困难的编程问题，如果忘记回收了会浪费内存。如果过早回收了，将会出现无效变量。如果重复回收，这也是个 bug。为此，Rust的设计者为每一个内存的分配配对了一个释放规则，这个规则由所有权来保证