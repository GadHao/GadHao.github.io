---
layout: post
title: '深入理解计算机系统 - 信息的表示和处理'
date: 2020-09-15
author: HANABI
color: rgb(54,59,64)
tags: 地基系列 计算机系统
usemathjax: true
---

> 在这一章，我们会了解表示基本数据类型的方法，机器级指令如何操作这样的数据，编译器如何将C程序翻译成这样的指令。接着会研究几种实现处理器的方法，帮助我们更好地了解硬件资源如何被用来执行命令。在深入了解了如何表示和执行应用程序之后，我们将学会一些技巧，用来写出安全、可靠且充分利用计算机资源的程序

## 信息的表示和处理

现代计算机存储和处理的信息以二值信号表示。这些二进制数字，或者称为位(bit)，形成了数字革命的基础。以前，大家熟悉并使用了1000多年的十进制数字起源于印度，在12世纪被阿拉伯数学家改进，并在13世纪被意大利数学家Leonardo Pisano(更为大家熟知的名字是Fibonacci)带到西方。

对于有10个手指的人类，使用十进制表示法是很自然的事情，但是当构造存储和处理信息的机器时，二进制值工作得更好。其可以更容易地被表示、存储和传输，里如可以表示为卡片上有没有孔洞、导线上的高电压或低电压，或者顺时针或逆时针的磁场。对二值信号进行存储和执行计算的电子电路非常简单可靠，制造商能够在一个单独的硅片上集成数百万甚至数十亿个这样的电路。

单个的位不是很有用，然而当把位组合在一起，再加上某种解释(interpretation)，就可以赋予它们含义，并用来表示任何有限集合的元素。比如，使用一个二进制数字系统，我们能够用位组来编码非负数。通过标准的字符码，我们能够对文档中的字母和符号进行编码。

我们研究三种最重要的数字表示：

1. **无符号(unsigned)**编码：表示大于或等于0的数字
2. **补码(two's-complement)**编码：表示有符号整数
3. **浮点数(floating-point)**编码：表示实数的科学计数法的以2为基数的版本

计算机的表示法是用有限数量的位来对一个数字编码，所以如果结果太大以至不能表示时，某些运算就会溢出(overflow)。例如，32位的`int`类型不能容纳`200*300*400*500`的结果

浮点运算有不同的数学属性，当其溢出时，会产生特殊的值`+∞`，由于表示的精度有限，浮点运算是不可结合的，例如，在很多机器上，C表达式(3.14+1e20)-1e20求得的值会是0.0，而3.14+(1e20-1e20)求得的值会是3.14

这种情况在整数运算中不会出现，因为整数表示的范围虽然小，但是是精确的；而浮点数虽然可以编码较大的数值范围，但是这种表示只是近似的

为了使编写的程序能在全部数值范围内正确工作，而且具有可以跨越不同机器、操作系统和编译器组合的可移植性，了解可以表示的数字值的范围、位级表示、算术运算的属性是非常重要的

### 信息存储

大多数计算机使用8位的块，或者字节(byte)，作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为*虚拟内存(virtual address space)*。这个虚拟地址空间只是一个展现给机器级程序的概念性映像，实际的实现结合了动态随机访问存储器(DRAM)、闪存、磁盘存储器、特殊硬件以及操作系统，为程序提供一个看上去统一的字节数组。

#### 十六进制表示法

一个字节由8位组成。在二进制标识法中，它的值域是00000000 ~ 11111111，看成十进制整数，就是0 ~ 255。两种符号标识发对于描述位模式都不是很方便。二进制标识发太冗长，十进制表示法与位模式的互相转换很麻烦。替代的方法是使用十六进制(hexadecimal)数来表示位模式。十六进制(简写为"hex")使用数字0 ~ 9以及字符A ~ F来表示16个可能的值。用十六进制来书写，一个字节的值域为00 ~ FF

![](/assets/img/CSAPP-21.JPG)

在C语言中，以Ox或OX开头的数字常量常被认为是十六进制的值。字符A ~ F既可以是大写，也可以是小写。例如，我们可以将数字FA1D37B(16进制)写作OxFA1D37B，或者Oxfa1d37b，甚至是大小写混合，在这本书里，是用C表示法来表示十六进制的

编写机器级程序的一个常见任务就是在位模式的十进制、二进制和十六进制表示之间人工转换。二进制和十六进制之间的转换比较简单直接，因为可以一次执行一个十六进制数字的转换。

比如，一个数字0x173A4C，可以通过展开每个十六进制数字，将其转换成二进制：

`1:0001` `7:0111` `3:0011` `A:1010` `4:0100` `C:1100`

这样就得到了二进制表示：`000101110011101001001100`

反过来，如果给定了一个二进制数字`1111001010110110110011`，可以通过首先把它分为每4位一组来转换为十六进制。不过要注意，如果总位数不是4的倍数，最左边的一组可以少于4位，前面用0补足

`11:3` `1100:C` `1010:A` `1101:D` `1011:B` `0011:3`

#### 字数据大小

每台计算机都有一个字长(word size)，指明指针数据的标称大小(nominal size)。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于以字长为w位的机器而言，虚拟地址的范围为0 ~ 2的w次方-1，程序最多访问2的w次方个字节

最近这些年，出现了大规模从32位字长机器到64位字长机器的迁移。32位字长限制虚拟地址空间位4千兆字节(写作4GB)，而扩展到64位字长使得虚拟地址空间为16EB，大约是1.84*10的19次方字节

大多数64位机器也可以运行为32位机器编译的程序，这是一种向后兼容，将程序称为"32位程序"或"64位程序"时，区别在于该程序是如何编译的，而不是其运行的机器类型。

![](/assets/img/CSAPP-22.JPG)

为了避免由于依赖"典型"大小和不同编译器设置带来的奇怪行为，ISO C99引入了一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化。其中就有`int32_t`和`int64_t`，分别位4个字节和8个字节，使用确定大小的整数类型是程序员准确控制数据表示的最佳途径

大部分数据类型都编码为有符号数值，除非有前缀关键字`unsigned`或对确定大小的数据类型使用了特定的无符号声明。对关键字的顺序以及包括还是省略可选关键字来说，C语言允许存在多种形式，比如，这里所有的声明都是一个意思：

- `unsigned long`
- `unsigned long int`
- `long unsigned`
- `long unsigned int`

上面的图中还展示了指针(图中使用了一个被声明为类型"char * "的变量)，使用程序的全字长

> 在C中，任何数据类型`T`，声明`T *p;`，表明`p`是一个指针变量，指向一个类型为`T`的对象。例如`char *p`就将一个指针声明为指向一个`char`类型的变量

程序员应该力图使他们的程序在不同的机器和编译器上可移植，可移植的一个方面就是使程序对不同数据类型的确切大小不敏感。许多程序编写都假设为上面图中32位程序的字节分配。随着64位机器的日益普及，在将这些程序移植到新机器上时，比如有许多程序员假设一个声明为`int`类型的程序对象能被用来存储一个指针。这在大多数32位的机器上能正常功能，但是在一台64位的机器上却会导致问题。

#### 寻址和字节顺序

对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。在几乎所有机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。例如，假设一个类型为`int`的变量`x`的地址为0x100，也就是说，地址表达式`&x`的值为0x100。那么，如果x为32位表示，x的4个字节将被存储在内存的0x100、0x101、0x102和0x103位置

排列表示一个对象的字节有两个通用的规则，小端法(little endian)和大端法(big endian)，分别表示在内存中按照最低有效字节到最高有效字节顺寻存储和从最高有效字节到最低有效字节的顺序存储。

假设变量`x`的类型位`int`，位于地址0x100处，它的十六进制值为0x01234567。地址范围0x100 ~ 0x103的字节顺序依赖于机器的类型：

![](/assets/img/CSAPP-23.JPG)

在字0x01234567中，高位字节的十六进制位0x01，而低位字节值为0x67

大多数Intel兼容机都只用小端模式，另一方面，IBM和Oracle的大多数机器则是按照大端模式操作。许多比较新的微处理器使用的是双端法(bi-endian)，也就是说可以把它们配置成作为打断或者小段的机器运行。实际情况中，一旦选择了特定操作系统，字节顺序就固定了。选择何种字节顺序没有技术上的理由，只要选择了一种规则并且一直遵循，对于哪种字节排序的选择都是任意的。

对于大多数应用程序员来说，其机器所使用的字节顺序是完全不可见的。不过有时候，字节顺序会成为问题。在不同类型的机器之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反过来时，接受程序发现里面的字节成了反序的。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为它的内部表示

当阅读小端法机器生成的机器级程序表示时，经常会将字节按照相反的顺序显示。因为按照小端法，最低有效位在右边，所以会从右边开始排，这值得注意

还有一种情况是当编写规避正常的类型系统的程序时。在C语言中，可以通过强制类型转换(cast)或联合(union)来允许一种数据引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同。虽然很多应用编程都强烈不推荐这种编码技巧，但是它们对系统及编程来说是非常有用的

看这段代码：

```c
# include <stdio.h>
typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, size_t len){
    size_t i;
    for (i = 0; i < len; i++)
        printf(" %.2x", start[i]);
    printf("\n");
}

void show_int(int x){
    show_bytes((byte_pointer) &x, sizeof(int));
}

void show_float(float x){
    show_bytes((byte_pointer) &x, sizeof(float));
}

void show_pointer(void *x){
    show_bytes((byte_pointer) &x, sizeof(void *))
}
```

这段代码使用强制类型转换来访问和打印不同程序对象的字节表示。我们用`typedef`将数据类型`byte_pointer`定义为一个指向类型为`unsigned char`的对象的指针。这样一个字节指针引用一个字节序列，每个字节都被认为是一个非负整数。上面的代码中`show_bytes`函数传入了一个字节序列的地址(传入了字节指针和字节数)，字节数的数据类型是`size_t`，表示数据结构大小的首选数据类型。`show_bytes`打印出每个以十六进制表示的字节。C格式化指令`%.2x`表明整数必须用至少两个数字的十六进制格式输出

`show_bytes`之后的三个函数分别用`show_bytes`来输出了类型为`int`、`float`和`void *`的C程序对象的字节表示。在调用`show_bytes`时，传入的是被强制转换为`unsigned char *`类型的指向它们参数`x`的指针`&x`，这种强制类型转换告诉编译器，程序应该把这个指针看成指向一个字节序列，而不是指向一个原始数据类型的对象。然后，这个指针会被看成是对象使用的最低字节地址。注意这里使用了`sizeof`运算符来确定对象使用的字节数。一般来说，`sizeof(T)`返回存储一个类型为`T`的对象锁需要的字节数。使用`sizeof`而不是固定值，也有利于之后程序的移植。

![](/assets/img/CSAPP-24.JPG)

上图是在不同的机器/操作系统调用前面代码的输出结果，可以看到，除了数值类型因为小端法与大端法造成的字节输出顺序的不同之外，指针值也是完全不同的，不同的机器/操作系统使用不同的存储分配规则。另一个值得注意的特性是上面除了Linux 64使用8字节地址之外，其他操作系统都是使用4字节地址。

> C语言小技巧：`typeof`声明提供了一种给数据类型命名的方式。这能极大改善代码的可读性，因为深度嵌套的类型声明很难读懂；·`printf`(以及`fprintf`和`sprintf`)提供了一种打印信息的方式，在第一个参数格式串(format string)里，每个以`%`开始的字符序列都表示如何格式化下一个参数，比较典型的有`%d`是输出一个十进制整数，而`%c`是输出一个字符，其编码由参数给出，指定确定大小数据类型的格式，如`int32_t`，要更复杂一些，之后会提到
>
> 在函数`show_bytes`中，我们看到指针和数组之间紧密的关系，之后会详细介绍这一点。在代码中，我们还可以看到取地址运算符`&`，这分别创建了指向三种不同类型的`x`的指针，在这里三个指针的类型分别为`int*`、`float*`和`void **`(数据类型void *是一种特殊类型的指针，没有相关联的类型信息)
>
> 强制类型转换运算符可以将一种数据类型转换为另一种，比如`(byte_pointer)&x`表明无论指针`&x`以前是什么类型，它现在就是一个指向数据类型为`unsigned char`的指针。这里给出的强制类型转换不会改变真实的指针，它们只是告诉编译器以新的数据类型来看代被指向的数据。

#### 表示字符串

C语言中字符串被编码为一个以`null`(其值为0)字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是ASCII字符码。如果我们以参数`"12345"`(包括终止符)来运行上面的代码，我们得到的结果是`31 32 33 34 35 00`，注意，十进制数字`x`的`ASCII`码正好是`0x3x`，而终止字节的十六进制表示为`0x00`。在使用ASCII码作为字符码的任何系统上都得到相同的效果，与字节顺序喝字大小规则无关。所以，文本数据比二进制数据具有更强的平台独立性。

#### 布尔代数简介

二进制是计算机编码、存储和操作信息的核心。源于1850年前后乔治布尔(George Boole，1815-1864)的工作，产生了丰富的数学知识体系，所以也被称为布尔代数(Boolean algebra)。布尔注意到通过将逻辑值TRUE(真)和FALSE(假)编码为二进制值1和0，能够设计出一种代数，以研究逻辑推理的基本原则。

布尔代数在数字系统的设计和分析中扮演着重要的角色，四个布尔运算符(`&`，`|`，`^`，`~`)可以扩展到位向量的运算，位向量就是固定长度为w、由0和1组成的串。位向量的运算可以定义成参数的每个对应元素之间的运算。假如a和b分别代表两个长度均为w的位向量，我们将a&b也定义为一个长度为w的位向量，其中第i个元素等于*ai&bi*，*0<=i<w*。可以用类似的方式将运算|、^和~扩展到位向量上。

比如w=4，参数a=[0110]，b=[1100]，那么4种运算a&b、a|b、a^b和~b分别得到以下结果

![](\assets\img\CSAPP-25.JPG)

这里有一道练习题：

![](\assets\img\CSAPP-26.JPG)

答案：`10010110`、`10101010`、`01000001`、`01111101`、`00111100`

> 布尔代数和整数运算有很多相似之处，比如，乘法对加法的分配律，写为`a*(b+c)=(a*b)+(a*c)`，而布尔运算`&`对`|`的分配律，写为`a&(b|c)=(a&b)|(a&c)`。此外，布尔运算`|`对`&`也有分配律，写为`a|(b&c)=(a|b)&(a|c)`
>
> 当考虑长度为w的位向量上的`^`，`&`和`~`运算时，会得到一种不同的数学形式，我们称之为*布尔环(Boolean ring)*，布尔环与整数运算有很多相同的属性。比如，整数运算的一个属性是每个值`x`都有一个*加法逆元(additive inverse)*`-x`使得`x+(-x)=0`。布尔环也有类似的属性，这里的"加法"运算是`^`，不过这时每个元素的加法逆元是它自己本身。也就是说，对于任何值`a`来说，`a^a=0`，这里我们用`0`来表示全0的位向量。可以看到对单个位来说这是成立的，即`0^0=1^1=0`，将这个扩展到位向量也是成立的。当我们重新排列组合顺序，这个属性也仍然成立，因此有`(a^b)^a=b`[^1]。这个属性会引起一些很有趣的结果和聪明的技巧，在后面的练习题中会探讨。

位向量一个很有用的应用就是表示有限集合。比如我们用位向量`a:[01101001]`表示集合`A={0,3,5,6}`，而`b:[01010101]`表示集合`B={0,2,4,6}`(注意我们是从位向量的右边往左边看)。使用这种编码集合的方法，布尔运算`|`和`&`分别对应于集合的并和交，而`~`对应集合的补集。比如在前面的例子里，运算`a&b`得到位向量`[01000001]`，而`A∩B={0，6}`，在大量实际应用中，我们都能看到用位向量来对集合编码，在之后也会接触到。

这里有一道练习题

![](\assets\img\CSAPP-27.JPG)

答案：

A.`~黑色 = 白色`，`~红色 = 蓝绿色`，`~蓝色 = 黄色`，`~红紫色 = 绿色`，反过来也是一样

B.`蓝色|绿色 = 001|010 = 011 = 蓝绿色`，`黄色&蓝绿色 = 110&011 = 010 = 绿色`，`红色^红紫色 = 100^101 = 001 = 蓝色`



#### C语言中的位级运算

C语言的一个很有用的特性就是它支持按位布尔运算。事实上，我们在布尔运算中使用的那些符号就是C语言所使用的：

`|`就是`OR(或)`，`&`就是`AND(与)`，`~`就是`NOT(取反)`，`^`就是`EXCLUSIVE-OR(异或)`。这些运算能运用到任何"整型"的数据类型上，这里有一张图，是一些对`char`数据类型表达式求值的例子：

![](\assets\img\CSAPP-28.JPG)

正如图上表示的那样，确定一个位级表达式的结果最好的方法，就是将十六进制的参数扩展成二进制表示并执行二进制运算，然后转换回十六进制

这里还有几道练习题：

![](/assets/img/CSAPP-29.JPG)

答案：

第一步：`a` `a^b`

第二步：`b` `a^b`

第三步：`b` a



![](/assets/img/CSAPP-30.JPG)

答案：

Ａ.从`first`是`0`，`last`是`2k`的时候开始循环，一直到`first<=last`的时候结束，假设到最后`first`的值为`n`，则最后`n=2k-n`的时候结束，所以到最后`first`和`last`的值都是`k`

B.因为此时两个数相同，异或运算的结果均为0

C.把`first<=last`改为`first<last`

位级运算的几个常见算法就是实现掩码运算，这里的掩码指的是一个位模式，表示从一个字中选出的位的集合。比如用掩码`0xFF`表示一个字的低位字节。位级运算`x&0xFF`生成一个由`x`的最低有效字节组成的值，其他的字节就被置为0，比如，对于`x=0x89ABCDEF`，其表达式得到`0x000000EF`，即我们得到了其最低的八位的值。

![](/assets/img/CSAPP-31.JPG)

![](/assets/img/CSAPP-32.JPG)

答案：

`bis(x,y)` `bis(bic(x,y),bic(y,x))`

`bis`和`OR`等价，如果`x`或`y`对应的位为1，则最后的结果相应的位会是`1`，所以得到第一个答案，另外，`bic(x,m)`等价于`x&~m`，只有当`x`对应的位为1且`m`对应的位为0的时候，最后的结果的对应位才等于1，因为`x^y`等价于`(x&~y)|(~x&y)`，所以得到第二个答案

关于这个答案，首先一定要仔细审题，理解`bis`和`bic`指令的作用，然后要理解这些操作的等价关系，特别是对于这里的`bic`操作，在`m`为1的每个位置，将`z`对应的位设置为0，也就是说和上面解释的一样，`m`对应的位为0且`x`对应的位不为0，最后的结果的对应位才为1

#### C语言中的逻辑运算

C语言还提供了一组逻辑运算符`||`、`&&`和`!`，分别对应命题逻辑中的`OR`、`AND`和`NOT`运算。逻辑运算很容易和位级运算相混淆，但是它们的功能是完全不同的。逻辑运算认为所有非零的参数都表示TRUE，而参数0表示FALSE。它们返回1或者0，分别表示结果为TRUE或者为FALSE。这里是一些示例：

![](/assets/img/CSAPP-33.JPG)

可以观察到，按位运算只有在特殊条件下，即参数被限制为0或者1时，才与其对应的逻辑运算有相同的行为。

逻辑运算符`&&`和`||`与 它们对应的位级运算`&`和`|`之间第二个重要的区别是，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。

![](/assets/img/CSAPP-34.JPG)

这里直接做第二题：`!(x^y)`



#### C语言中的移位运算

C语言还提供了一组移位运算，向左或者向右移动位模式。对于一个位表示为$$[x_{w-1},x_{w-2},…,x_0]$$的操作数$$x$$，C表达式`x<<k`会生成一个值，其位表示为$$[x_{w-k-1},x_{w-k-2},…,x_0,0,…,0]$$。也就是说，`x`向左移动`k`位，丢弃最高的`k`位，并在右端补`k`个0。移位量应该是一个0~w-1之间的值。移位运算是从左至右可结合的，所以`x<<j<<k`等价于`(x<<j)<<k`

有一个相应的右移运算`x>>k`，但是它的行为有点微妙。一般来说，机器支持两种形式的右移：逻辑右移和算数右移。逻辑右移在左端补`k`个0，得到的结果是$$[0,…,0,x_{w-1},x_{w-2},…,x_k]$$。算数右移是在左端补`k`个最高有效位的值，得到的结果是$$[x_{w-1},…,x_{w-1},x_{w-1},x_{w-2},…,x_k]$$。这种做法看上去可能有点奇特，但是我们会发现它对有符号整数数据的运算非常有用

让我们看一个例子，这个例子对一个8位参数`x`的两个不同的值做了不同的移位操作：

![](/assets/img/CSAPP-35.JPG)

图中斜体数字表示的是因为移位运算而填充的值，可以看到除了算数右移`[10010101]`时，其他情况填充的值都是0，因为其最高位是1，所以算数右移之后填充的也是1

C语言标准没有明确定义有符号数应该使用哪种类型的右移，即算数右移或逻辑右移都可以，所以也意味着可能会出现可以执行问题。在实际情况中，几乎所有的编译器/机器都对有符号数使用算数右移，且虚度哦程序员也都假设机器会使用这种右移。而对于无符号数来说，右移必须是逻辑的。而Java中对右移的具体方式有明确的定义，比如`x>>k`会将`x`算数右移`k`个位置，而`x>>>k`会对`x`做逻辑右移

> C语言标准小心地规避了当位移量大于等于待移位值的位数的情况，实际上位移量会通过计算`k mod w`得到，不过这种行为对于C程序来说是没有保证的，所以应该保持位移量小于待移动位值的位数

> 因为加法(和减法)的优先级比移位运算要高。所以表达式`1<<2+3<<4`等价于`1<<(2+3)<<4`，答案是512

> 思考移位运算的最好方式是使用二进制表示，将最初的值转换为二进制，执行移位运算，然后再转换回十六进制

### 整数表示

接着，我们来学习用位来编码整数的两种不同方式：一种只能表示非负数，而另一种能够表示负数、零和正数。后面我们会看到它们在数学属性和机器级实现方面密切相关，并且还会研究扩展或者收缩一个已编码整数以适应不同长度表示的效果。

这里会涉及到一些数学术语，用于精确定义和描述计算机如何编码和操作整数，这里先把相关的图放在以便之后参考

![](/assets/img/CSAPP-36.JPG)

#### 整数数据类型

C语言支持多种整型数据类型——表示有限范围的整数。每种类型都能用关键字来指定大小，这些关键字包括`char`、`short`、`long`，同时还可以指示被表示的数字是非负数(声明为`unsigned`)，或者可能是负数(默认)。为这些类型分配的字节数根据程序编译为32位还是64位也会有所不同，根据字节分配，不同的大小所能表示的值的范围是不同的。这里唯一一个与机器相关的取值范围是`long`类型的，大多数64位机器使用8个字节的表示，比32位机器上使用的4个字节的表示的取值范围大很多

![](/assets/img/CSAPP-37.JPG)

![](/assets/img/CSAPP-38.JPG)

这里有一个很值得注意的特点是取值范围是不对称的——负数的范围比正数的范围大1，当我们考虑如何考虑负数的时候，会看到为什么会这样

C语言标准定义了每种数据类型必须能够表示的最小的取值范围。它们的取值范围和之前图上的典型实现一样或者小一些。除了固定大小的数据类型是例外，我们看到它们只要求正数和负数的取值范围是对称的。另外`int`可以用2个字节的数字来实现，`long`可以用4个字节的数字来实现

![](/assets/img/CSAPP-39.JPG)

> C和C++都支持有符号(默认)和无符号数。Java只支持有符号数



#### 无符号数的编码

假设有一个整数数据类型有`w`位。我们可以将位向量写成$$ \vec{x}$$，表示整个向量，或者写成$$[x_{w-1},x_{w-2},…,x_0]$$，表示向量中的每一位。把$$ \vec{x}$$看作一个二进制表示的数，就获得了$$ \vec{x}$$的无符号表示。在这个编码中，每个位$$x_i$$都取值为0或1，后一种取值意味着数值$$2^i$$应为数字值的一部分。我们用一个函数$$B2U_w$$(Binary to Unsigned的缩写，长度为w)来表示

![](/assets/img/CSAPP-40.JPG)

在这个等式中，符号"≐"表示左边被定义为等于右边。函数$$B2U_w$$将一个长度为w的0、1串映射到非负整数，比如下面几种情况：

![](/assets/img/CSAPP-41.JPG)

在图中，我们用$$2^i$$的指向右侧箭头的条表示每个位的位置i，每个位向量对应的数值都等于所有值为1的位对应的长度之和

![](/assets/img/CSAPP-42.JPG)

所以，当这个串的长度为w时的取值范围是在它的内容为全0到全1之间的，也就是整数值$$UMax_w≐\sum^{w-1}_{i=0}2^i=2^w-1$$

以4位情况为例，$$UMax_4=B2U_4([1111])=2^4-1=15$$。因此，函数$$B2Uw$$能够被定义为一个映射$$B2U_w:\{0,1\}^w→\{0,…,2^w-1\}$$

无符号的二进制表示有一个很重要的属性，也就是每个介于$$0$$到$$2^w$$-1之间的数都有唯一一个w位的值编码。例如，十进制值11作为无符号数，只有一个四位的表示，即$$[1011]$$。我们用数学原理来重点讲述它，先表述原理再解释。

原理：无符号数编码的唯一性

函数$$B2U_w$$是一个双射，所谓双射是一个数学术语，意思是一个函数$$f$$有两面：它将数值$$x$$映射为数值$$y$$，即$$y=f(x)$$，但它也可以反向操作，因为对每一个$$y$$而言，都有唯一一个数值$$x$$使得$$f(x)=y$$。这可以用反函数$$f^{-1}$$来表示，即$$x=f^{-1}(y)$$，在本例中也是如此，函数$$B2U_w$$将每一个长度为$$w$$的位向量都映射为$$0$$到$$2^w-1$$之间的一个唯一值；反过来，我们称其为$$U2B_w$$(即"无符号数到二进制")，在$$0$$到$$2^w-1$$之间的每一个整数都可以映射为一个唯一的长度为$$w$$的位模式

#### 补码编码

对于许多应用，我们还希望表示负数值。最常见的有符号数的计算机表示方法就是*补码(two's-complement)*形式。在这个定义中，将字的最高有效位解释为*负权(negative weight)*。我们用函数$$B2T_w$$(Binary to Two's-complement的缩写，长度为$$w$$)来表示：

原理：补码编码的定义

对向量$$\vec{x}=[x_{w-1},x_{w-2},…,x_0]$$：

$$B2T_w(\vec{x})≐-x_{w-1}2^{w-1}+\sum^{w-2}_{i=0}x_i2^i$$

最高有效位$$x_{w-1}$$也称为符号位，它的"权重"为$-2^{w-1}$，是无符号表示中权重的负数。符号位被设置为1时，表示值为负，而当设置为0时，值为非负。这里来看几个示例：

$$B2T4([0001])=-0*2^3+0*2^2+0*2^1+1*2^0=0+0+0+1=1$$

$$B2T4([0101])=-0*2^3+1*2^2+0*2^1+1*2^0=0+4+0+1=5$$

$$B2T4([1011])=-1*2^3+0*2^2+1*2^1+1*2^0=-8+0+2+1=-5$$

$$B2T4([1111])=-1*2^3+1*2^2+1*2^1+1*2^0=-8+4+2+1=-1$$

![](/assets/img/CSAPP-43.JPG)

从图上可以看出，与一个位向量相关联的数值是由可能的向左指的条和向右直的条加起来决定的

可以看到，这张图的位模式和之前展示的无符号整数的位模式是一样的，但是当最高有效位是1时，数值是不同的，这是因为在第一种情况中，最高有效位的权重是+8，而在这里，它的权重是-8

所以我们可以想到，$$w$$位补码

<br><br><br><br><br><br>

[^1]: 关于这里的异或运算，一开始可能不太理解，首先要明白，异或，就是找出两个位向量里面不同的元素，这里因为每个元素的加法逆元这个属性即使交换之后也成立，所以这里其实相当于`(a^a)^b`，即`b`与`0`相异或，值还是`b`

