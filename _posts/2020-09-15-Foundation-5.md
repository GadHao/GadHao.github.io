---
layout: post
title: '深入理解计算机系统 - 信息的表示和处理'
date: 2020-09-15
author: HANABI
color: rgb(54,59,64)
tags: 地基系列 计算机系统
---

> 在这一章，我们会了解表示基本数据类型的方法，机器级指令如何操作这样的数据，编译器如何将C程序翻译成这样的指令。接着会研究几种实现处理器的方法，帮助我们更好地了解硬件资源如何被用来执行命令。在深入了解了如何表示和执行应用程序之后，我们将学会一些技巧，用来写出安全、可靠且充分利用计算机资源的程序

## 信息的表示和处理

现代计算机存储和处理的信息以二值信号表示。这些二进制数字，或者称为位(bit)，形成了数字革命的基础。以前，大家熟悉并使用了1000多年的十进制数字起源于印度，在12世纪被阿拉伯数学家改进，并在13世纪被意大利数学家Leonardo Pisano(更为大家熟知的名字是Fibonacci)带到西方。

对于有10个手指的人类，使用十进制表示法是很自然的事情，但是当构造存储和处理信息的机器时，二进制值工作得更好。其可以更容易地被表示、存储和传输，里如可以表示为卡片上有没有孔洞、导线上的高电压或低电压，或者顺时针或逆时针的磁场。对二值信号进行存储和执行计算的电子电路非常简单可靠，制造商能够在一个单独的硅片上集成数百万甚至数十亿个这样的电路。

单个的位不是很有用，然而当把位组合在一起，再加上某种解释(interpretation)，就可以赋予它们含义，并用来表示任何有限集合的元素。比如，使用一个二进制数字系统，我们能够用位组来编码非负数。通过标准的字符码，我们能够对文档中的字母和符号进行编码。

我们研究三种最重要的数字表示：

1. **无符号(unsigned)**编码：表示大于或等于0的数字
2. **补码(two's-complement)**编码：表示有符号整数
3. **浮点数(floating-point)**编码：表示实数的科学计数法的以2为基数的版本

计算机的表示法是用有限数量的位来对一个数字编码，所以如果结果太大以至不能表示时，某些运算就会溢出(overflow)。例如，32位的`int`类型不能容纳`200*300*400*500`的结果

浮点运算有不同的数学属性，当其溢出时，会产生特殊的值`+∞`，由于表示的精度有限，浮点运算是不可结合的，例如，在很多机器上，C表达式(3.14+1e20)-1e20求得的值会是0.0，而3.14+(1e20-1e20)求得的值会是3.14

这种情况在整数运算中不会出现，因为整数表示的范围虽然小，但是是精确的；而浮点数虽然可以编码较大的数值范围，但是这种表示只是近似的

为了使编写的程序能在全部数值范围内正确工作，而且具有可以跨越不同机器、操作系统和编译器组合的可移植性，了解可以表示的数字值的范围、位级表示、算术运算的属性是非常重要的

### 信息存储

大多数计算机使用8位的块，或者字节(byte)，作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为*虚拟内存(virtual address space)*。这个虚拟地址空间只是一个展现给机器级程序的概念性映像，实际的实现结合了动态随机访问存储器(DRAM)、闪存、磁盘存储器、特殊硬件以及操作系统，为程序提供一个看上去统一的字节数组。

#### 十六进制表示法

一个字节由8位组成。在二进制标识法中，它的值域是00000000 ~ 11111111，看成十进制整数，就是0 ~ 255。两种符号标识发对于描述位模式都不是很方便。二进制标识发太冗长，十进制表示法与位模式的互相转换很麻烦。替代的方法是使用十六进制(hexadecimal)数来表示位模式。十六进制(简写为"hex")使用数字0 ~ 9以及字符A ~ F来表示16个可能的值。用十六进制来书写，一个字节的值域为00 ~ FF

![](/assets/img/CSAPP-21.JPG)

在C语言中，以Ox或OX开头的数字常量常被认为是十六进制的值。字符A ~ F既可以是大写，也可以是小写。例如，我们可以将数字FA1D37B(16进制)写作OxFA1D37B，或者Oxfa1d37b，甚至是大小写混合，在这本书里，是用C表示法来表示十六进制的

编写机器级程序的一个常见任务就是在位模式的十进制、二进制和十六进制表示之间人工转换。二进制和十六进制之间的转换比较简单直接，因为可以一次执行一个十六进制数字的转换。

比如，一个数字0x173A4C，可以通过展开每个十六进制数字，将其转换成二进制：

`1:0001` `7:0111` `3:0011` `A:1010` `4:0100` `C:1100`

这样就得到了二进制表示：`000101110011101001001100`

反过来，如果给定了一个二进制数字`1111001010110110110011`，可以通过首先把它分为每4位一组来转换为十六进制。不过要注意，如果总位数不是4的倍数，最左边的一组可以少于4位，前面用0补足

`11:3` `1100:C` `1010:A` `1101:D` `1011:B` `0011:3`

#### 字数据大小

每台计算机都有一个字长(word size)，指明指针数据的标称大小(nominal size)。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于以字长为w位的机器而言，虚拟地址的范围为0 ~ 2的w次方-1，程序最多访问2的w次方个字节

最近这些年，出现了大规模从32位字长机器到64位字长机器的迁移。32位字长限制虚拟地址空间位4千兆字节(写作4GB)，而扩展到64位字长使得虚拟地址空间为16EB，大约是1.84*10的19次方字节

大多数64位机器也可以运行为32位机器编译的程序，这是一种向后兼容，将程序称为"32位程序"或"64位程序"时，区别在于该程序是如何编译的，而不是其运行的机器类型。

![](/assets/img/CSAPP-22.JPG)

为了避免由于依赖"典型"大小和不同编译器设置带来的奇怪行为，ISO C99引入了一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化。其中就有`int32_t`和`int64_t`，分别位4个字节和8个字节，使用确定大小的整数类型是程序员准确控制数据表示的最佳途径

大部分数据类型都编码为有符号数值，除非有前缀关键字`unsigned`或对确定大小的数据类型使用了特定的无符号声明。对关键字的顺序以及包括还是省略可选关键字来说，C语言允许存在多种形式，比如，这里所有的声明都是一个意思：

- `unsigned long`
- `unsigned long int`
- `long unsigned`
- `long unsigned int`

上面的图中还展示了指针(图中使用了一个被声明为类型"char * "的变量)，使用程序的全字长

> 在C中，任何数据类型`T`，声明`T *p;`，表明`p`是一个指针变量，指向一个类型为`T`的对象。例如`char *p`就将一个指针声明为指向一个`char`类型的变量

程序员应该力图使他们的程序在不同的机器和编译器上可移植，可移植的一个方面就是使程序对不同数据类型的确切大小不敏感。许多程序编写都假设为上面图中32位程序的字节分配。随着64位机器的日益普及，在将这些程序移植到新机器上时，比如有许多程序员假设一个声明为`int`类型的程序对象能被用来存储一个指针。这在大多数32位的机器上能正常功能，但是在一台64位的机器上却会导致问题。

#### 寻址和字节顺序

对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。在几乎所有机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。例如，假设一个类型为`int`的变量`x`的地址为0x100，也就是说，地址表达式`&x`的值为0x100。那么，如果x为32位表示，x的4个字节将被存储在内存的0x100、0x101、0x102和0x103位置

排列表示一个对象的字节有两个通用的规则，小端法(little endian)和大端法(big endian)，分别表示在内存中按照最低有效字节到最高有效字节顺寻存储和从最高有效字节到最低有效字节的顺序存储。

假设变量`x`的类型位`int`，位于地址0x100处，它的十六进制值为0x01234567。地址范围0x100 ~ 0x103的字节顺序依赖于机器的类型：

![](/assets/img/CSAPP-23.JPG)

在字0x01234567中，高位字节的十六进制位0x01，而低位字节值为0x67

大多数Intel兼容机都只用小端模式，另一方面，IBM和Oracle的大多数机器则是按照大端模式操作。许多比较新的微处理器使用的是双端法(bi-endian)，也就是说可以把它们配置成作为打断或者小段的机器运行。实际情况中，一旦选择了特定操作系统，字节顺序就固定了。选择何种字节顺序没有技术上的理由，只要选择了一种规则并且一直遵循，对于哪种字节排序的选择都是任意的。