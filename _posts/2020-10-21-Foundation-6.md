---
layout: post
title: '计算机程序的构造和解释 - 程序涉及的基本元素'
date: 2020-10-21
author: HANABI
color: rgb(54,59,64)
tags: 地基系列 SICP 
usemathjax: true
---

> 这本书是麻省理工学院计算机科学的入门教材，对于看完这本书的目标，前言中是这样描述的：完成了这一科目的学生能对程序涉及的风格要素有一种很好的审美观。他们应该掌握了控制大型系统的复杂性的主要技术。他们应该能够取读50页长的程序，只要该程序是以一种值得模仿的形式写出来的。他们应该知道在什么时候哪些东西不需要取读，哪些东西不需要去理解。他们应该很有把握地去修改一个程序，同时又能保持原来作者的精神和风格



以书中这一段非常出名的文字为起点开始我们的SICP学习之路：

> **计算机语言并不仅仅是一种让计算机去执行操作的方式，更重要的，它是一种表述有关方法学的思想的新颖的形式化媒介，因此，程序必须写得能够供人们阅读，偶尔地去供计算机执行。其次，我们相信，在这一层次的课程里，最基本的材料并不是特定程序涉及语言的语法，不是高效完成某种功能的巧妙算法，也不是算法的数学分析或者计算机的本质基础，而是一些能够控制大型软件系统的复杂性的技术**



## 构造过程抽象

在初学程序设计时，我们可以随意试错，而在真实的程序设计中我们则需要极度小心，需要经验和智慧。有时在一个软件中出现的一小点毛病，就可能导致一架飞机或者一座水坝的灾难性损毁，或者一个工业机器人的自我破坏。软件工程大师们能组织好自己的程序，使自己能合理地确信这些程序所产生的计算过程将能完成预期的工作。他们可以事先看到自己系统的行为方式，知道如何去构造程序使得其中出现的意外问题不会导致灾难性的后果，而且，在发生了这种问题时，他们也能排除程序中的错误。设计良好的计算机系统就像设计良好的汽车或者核反应堆一样，具有某种模块化的设计，其中的各个部分都可以独立地构造、替换、排除错误

在这本书里面，我们将使用*Scheme*编程，它是一种*Lisp*方言(因为*Lisp*用户社团具有抵制制定这一语言的"官方"定义企图的传统，*Lisp*以一种试验性的非正式的方式不断演化，以满足用户的需要和实际实现的各种考虑，所以已经形成了一组方言，它们共享着初始语言的大部分特征，也可能有这样或那样的重要差异)，*Lisp*语言是现今被使用得相对广泛的第二悠久的编程语言(第一是*Fortran*)，它的名字来自于表处理(List Processing)，其设计是为了提供符号计算的能力，以便能用于解决一些程序设计问题，例如代数表达式的符号微分和积分。它包含了适用于这类目的的一些新数据对象，称为原子和表，这是它与那一时代的所有其他语言之间的最明显的不同之处

*Lisp*并不是一种预留语言，之所以用它作为讨论程序设计的基础是因为这一语言具有许多独有的特征，这些特征使得它称为研究重要程序的设计、构造，以及各种数据结构，并将其关联于支持它们的语言特征的一种极佳媒介。这些特征之中最重要就是：计算过程的*Lisp*描述本身又可以作为*Lisp*的数据来表示和操作。



### 程序设计的基本元素

**一个强有力的程序设计语言，不仅是一种智慧计算机执行任务的方式，它还应该称为一种框架，使我们能够在其中组织自己有关计算过程的思想。**这样当我们描述一个语言时，就需要将注意力特别放在这一预言所提供的，能够将简单的认知组合起来形成更复杂认识的方法方面，每一种强有力的语言都为此提供了三种机制：

- **基本表达形式，**用于表示语言所关心的最简单的个体
- **组合的方法**，从较简单的东西出发构造出复合元素的能力
- **抽象的方法**，为符合对象命名，并当作单元去操作的能力



#### 表达式

开始做程序设计，最简单方式就是去看语言是如何与解释器交互，输出结果的，比如在使用*Scheme*时，输入一个由数字组成的表达式`486`，解释器的响应是打印出`486`

可以用表示基本过程的表达形式(例如+或者*)，将表示数的表达式组合起来，形成复合表达式，表示要把这些过程应用于这些数，比如：

```scheme
(+ 137 349)
486

(- 1000 334)
666

(* 5 99)
495

(/ 10 5)
2

(+ 2.7 10)
12.7
```

像这种用一对括号括起一些表达式，形成一个表，用于表示一个过程应用的表达式称为**组合式**，在表里最左的元素称为**运算符**，其他元素都称为**运算对象**。想要得到这种组合式的值，将运算符所刻画的过程应用于那些运算对象即可

将运算符放在所有运算对象坐标的形式称为**前缀表示**，刚开始看到时可能会有些不习惯，这种表达式的有一些优点，其中之一就是它完全适用于可能带有任意个实参的过程，例如：

```scheme
(+ 21 35 12 7)
75
(* 25 4 12)
1000
```

在这里不会出现歧义，因为运算符总是最左边的元素，而整个表达式的范围也由括号界定

前缀表示的第二个优点是可以直接扩充，允许组合式**嵌套**，也就是说，允许组合式的元素本身又是组合式：

```scheme
(+ (* 3 5) (- 10 6))
19
```

原则上讲这种深度以及*Lisp*解释器可以求值的表达式的整体复杂性没有任何限制。倒是我们自己有可能被一些并不很复杂的表达式搞糊涂，例如：

```scheme
(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
```

对于这个表达式，解释器可以马上求值出57，但是可以看到，我们一眼求出值没有那么容易，因此，要遵循**美观打印**的格式规则，即我们平时所说的代码的美观性和可读性，通过将各个运算对象垂直对齐，并添加一些缩进，可以很好地显示出表达式的结构，我们将其写成这样：

```scheme
(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
```



#### 命名和环境

程序设计语言中一个必不可少的方面是它需要提供一种通过名字去使用计算对象的方式。我们将名字标识符称为**变量**，它的值也就是它所对应的那个对象

在*Scheme*里，给事物命名通过`define`(定义)的方式完成，输入：

```scheme
(define size 2)
```

这样解释器就将值2与名字`size`相关联，我们就可以通过这个名字去引用2了：

```scheme
size
2

(* 5 size)
10
```

`define`是我们所用的语言里最简单的抽象方法，因为如果每次用到计算得到的对象时都要重复写出它们的细节，是一件很不方便的事情。实际上，构造一个复杂的程序，也就是为了去一步步创建出越来越复杂的计算机对象。解释器使这种逐步的程序构造过程变得方便，让我们可以逐步创建起所需要的名字 - 对象关联。这种特征鼓励人们采用递增的方式去开发和调试程序。我们也可以看到，一个*Lisp*程序通常总是由一大批相对简单的过程组成的

我们将值与符号关联，之后又能提取出这些值，这意味着解释器必须维护某种存储能力。这种存储被称为**环境**(更精确地说，是全局环境，因为我们以后将看到，一个计算过程中完全可能涉及若干不同环境)



#### 组合式的求值

为了要把与过程性思维有关的各种问题隔离出来。让我们考虑组合式的求值问题。解释器本身就是按照下面过程工作的。

要求值一个组合式，做下面的事情：

1. 求值该组合式的各个子表达式
2. 将作为最左子表达式(运算符)的值的那个过程应用于相应的实际参数，所谓实际参数也就是其他子表达式(运算对象)的值

即使是这条简单的规则，也透露出程序设计语言中一个基本的原则，首先，为了对整个表达式求值，我们需要分别对这个表达式的每个元素求值，这是个递归的求值过程